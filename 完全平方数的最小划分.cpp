
完全平方数
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.


思想：大事化小，小事化了～。动态规划的思想

对于一个数：最坏情况 = n个 1^2；

思路： 如果能够把一个数的 分为一个数 + 一个平方数，那样就可以慢慢一步步分解出来知道 分解到1 不可再分
即递归思路 
目标数 n = a + b^2;  那么只需要将 a再分解成别的数的平方， 直到不能再分解

但是递归很明显开销大，容易超时。那么我们从小到大递推：
我们采用dp[] 一维数组进行动态记录，记录内容为0～n所有数的最小划分块。最终dp[n]将是我们想要的结果。
Dp【】 = min(dp[n], dp[n -b^2]+1)--->解释，最坏是n个1，最好就是一个平方数 + 一个数/0。➕0是刚好自己是一个平方数，即 n = b^2; dp[0]我们初始化为0了，所以➕1 不影响。




class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1,0);//+1为了避开0
        for(int i=0; i <= n; ++i)
        {
            dp[i] = i;//初步初始化而已，最坏情况n个1^2,
            //为了从小到大递推，那么必须知道i=0，1，时的情况
            for(int j =0; j * j <= i; ++j)
            {
                dp[i] =min(dp[i], dp[i-j*j] + 1);
            }
        }
        return dp[n];
    }
};